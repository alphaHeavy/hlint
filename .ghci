:set -fno-warn-overlapping-patterns -fwarn-unused-binds -fwarn-unused-imports
:set -isrc;.
:load Main

:def test const $ return ":main --test"
:def gen const $ return ":!runhaskell data\\HLint_Gen.hs"

:{
let _ghci_make dir flags = ":!" ++
        "(if not exist .hpc mkdir .hpc) && " ++
        "(if not exist .hpc\\" ++ dir ++ " mkdir .hpc\\" ++ dir ++ ") && " ++
        "ghc --make -isrc -i. src/Main.hs -w -odir .hpc/"++dir++" -hidir .hpc/"++dir++" -o .hpc/"++dir++"/hlint "++flags
:}
let _ghci_number def val = show $ case val of "" -> def; x -> read x

:{
:def self const $ return
    ":main src --report --hint=data/HLint_Hints.hs --find=src/Util.hs --find=src/HSE/Util.hs"
:}

:{
:def hpc const $ return $ unlines
    [_ghci_make "hpc" "-threaded -fhpc"
    ,":!del hlint.tix"
    ,":!.hpc\\hpc\\hlint --help"
    ,":!.hpc\\hpc\\hlint --test"
    ,":!.hpc\\hpc\\hlint src --report=.hpc\\hlint-report.html +RTS -N2"
    ,":!.hpc\\hpc\\hlint data --report=.hpc\\hlint-report.html +RTS -N2"
    ,":!hpc.exe markup hlint.tix --destdir=.hpc"
    ,":!hpc.exe report hlint.tix"
    ,":!del hlint.tix"
    ,":!start .hpc\\hpc_index_fun.html"]
:}

:{
:def prof \x ->
    let level = _ghci_number 1 x;
        dir = "prof" ++ level
    in return $ unlines
        [_ghci_make dir $ "-O"++level++" -prof -auto-all -caf-all -threaded"
        ,":!.hpc\\"++dir++"\\hlint src +RTS -p"
        ,":!start hlint.prof"]
:}

:{
:def bench \x -> return $ unlines
    [_ghci_make "bench" "-O -threaded"
    ,":!timer .hpc\\bench\\hlint src +RTS -N" ++ _ghci_number 1 x
    ,":!echo."]
:}

:{
:def scope \x -> return $ unlines
    [_ghci_make "scope" "-O -threaded -eventlog"
    ,":!.hpc\\scope\\hlint.exe src +RTS -ls -N" ++ _ghci_number 2 x
    ,":!start /b threadscope hlint.exe.eventlog"]
:}

:{
:def extra const $
    let msg = [":test - run the test suit"
              ,":self - run HLint on itself"
              ,":hpc - run and produce a program coverage report"
              ,":prof <N> - run and produce a profiling report (N=-O level [1])"
              ,":bench <N> - run the benchmark (should take about 1 second) (N=threads [1])"
              ,":scope <N> - run with threadscope (N=threads [2])"]
    in putStr (unlines msg) >> return []
:}
