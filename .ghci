:set -fno-warn-overlapping-patterns -fwarn-unused-binds -fwarn-unused-imports
:set -isrc;.
:load Main

:def test const $ return ":main --test"
:def gen const $ return ":!runhaskell data\\HLint_Gen.hs"


:{
:def self const $ return $ unlines
    [":redirOut newhints :main --find=src/Util.hs --find=src/HSE/Util.hs"
    ,"writeFile \"Hints.tmp\" $ unlines $ filter (not . Data.List.isPrefixOf \"Loading \") $ lines newhints"
    ,":main src --report --hint=data/HLint_Hints.hs --hint=Hints.tmp"]
:}

:{
:def hpc const $ return $ unlines
    [":!mkdir .hpc"
    ,":!ghc --make -isrc -i. src/Main.hs -w -fhpc -odir .hpc -hidir .hpc -threaded -o .hpc/hlint-test"
    ,":!del hlint-test.tix"
    ,":!.hpc\\hlint-test --help"
    ,":!.hpc\\hlint-test --test"
    ,":!.hpc\\hlint-test src --report=.hpc\\hlint-test-report.html +RTS -N3"
    ,":!.hpc\\hlint-test data --report=.hpc\\hlint-test-report.html +RTS -N3"
    ,":!hpc.exe markup hlint-test.tix --destdir=.hpc"
    ,":!hpc.exe report hlint-test.tix"
    ,":!del hlint-test.tix"
    ,":!start .hpc\\hpc_index_fun.html"]
:}

:{
:def prof \x ->
    let level = if x == "" then "1" else x ;
        dir = ".hpc\\prof" ++ level
    in if level `notElem` ["0","1","2"] then putStrLn "Error: argument to prof must be a number 0-2." >> return "" else
    return $ unlines
        [":!mkdir .hpc"
        ,":!mkdir " ++ dir
        ,":!ghc --make -isrc -i. src/Main.hs -w -odir "++dir++" -hidir "++dir++" -o "++dir++"/hlint -O"++level++" -prof -auto-all -caf-all"
        ,":!"++dir++"\\hlint src +RTS -p"
        ]
:}

:{
:def bench \x -> return $ unlines
    [":!mkdir .hpc"
    ,":!mkdir .hpc\\bench"
    ,":!ghc --make -isrc -i. src/Main.hs -w -odir .hpc/bench -hidir .hpc/bench -o .hpc/bench/hlint -O"
    ,":!.hpc\\bench\\hlint src +RTS -s"
    ]
:}


-- Begin copied material.
-- <http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/dot-squashed.ghci641>
let redirOut varcmd = case break Data.Char.isSpace varcmd of { (var,_:cmd) -> return $ unlines ["-- :set -fno-print-bind-result" ,"tmp <- System.Directory.getTemporaryDirectory" ,"(f,h) <- System.IO.openTempFile tmp \"ghci\"" ,"sto <- GHC.Handle.hDuplicate System.IO.stdout" ,"GHC.Handle.hDuplicateTo h System.IO.stdout" ,"System.IO.hClose h" ,cmd ,"GHC.Handle.hDuplicateTo sto System.IO.stdout" ,"let readFileNow f = readFile f >>= \\t->length t `seq` return t" ,var++" <- readFileNow f" ,"System.Directory.removeFile f"] ; _ -> return "putStrLn \"usage: :redirOut <var> <cmd>\"" }
:def redirOut redirOut
